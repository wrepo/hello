package main

import (
    "errors"
    "log"
    "os"
    "os/signal"
    "syscall"
    "unsafe"

    "github.com/cilium/ebpf/link"
    "github.com/cilium/ebpf/ringbuf"
    "github.com/cilium/ebpf/rlimit"
    "golang.org/x/sys/unix"
)

// $BPF_CLANG and $BPF_CFLAGS are set by the Makefile.
//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc $BPF_CLANG -cflags $BPF_CFLAGS -type event bpf ringbuffer.c -- -I../headers

func main() {
    // Name of the kernel function to trace.
    fn := "readline"
    binary := "/usr/local/bin/bash"  // 修改 bash 路径

    // Subscribe to signals for terminating the program.
    stopper := make(chan os.Signal, 1)
    signal.Notify(stopper, os.Interrupt, syscall.SIGTERM)

    // Allow the current process to lock memory for eBPF resources.
    if err := rlimit.RemoveMemlock(); err != nil {
        log.Fatal(err)
    }

    // Load pre-compiled programs and maps into the kernel.
    objs := bpfObjects{}
    if err := loadBpfObjects(&objs, nil); err != nil {
        log.Fatalf("loading objects: %v", err)
    }
    defer objs.Close()

    // 使用 Uretprobe 替代 Kprobe
    up, err := link.OpenExecutable(binary)
    if err != nil {
        log.Fatalf("opening executable: %s", err)
    }

    // 修改这部分代码
    probe, err := up.Uretprobe(fn, objs.UprobeReadline, nil)
    if err != nil {
        log.Fatalf("creating uretprobe: %s", err)
    }
    defer probe.Close()

    // Open a ringbuf reader from userspace RINGBUF map described in the
    // eBPF C program.
    rd, err := ringbuf.NewReader(objs.Events)
    if err != nil {
        log.Fatalf("opening ringbuf reader: %s", err)
    }
    defer rd.Close()

    // Close the reader when the process receives a signal, which will exit
    // the read loop.
    go func() {
        <-stopper

        if err := rd.Close(); err != nil {
            log.Fatalf("closing ringbuf reader: %s", err)
        }
    }()

    log.Println("Waiting for events..")

    // bpfEvent is generated by bpf2go.
    // 修改事件解析部分
    var event bpfEvent
    for {
        record, err := rd.Read()
        if err != nil {
            if errors.Is(err, ringbuf.ErrClosed) {
                log.Println("Received signal, exiting..")
                return
            }
            log.Printf("reading from reader: %s", err)
            continue
        }

        // 使用 copy 来复制数据
        copy((*[unsafe.Sizeof(event)]byte)(unsafe.Pointer(&event))[:], record.RawSample)

        log.Printf("pid: %d\tcomm: %s\tinput: %s\n", 
            event.Pid, 
            unix.ByteSliceToString(event.Comm[:]),
            unix.ByteSliceToString((*[256]byte)(unsafe.Pointer(&event.Input))[:]))

    }
}
